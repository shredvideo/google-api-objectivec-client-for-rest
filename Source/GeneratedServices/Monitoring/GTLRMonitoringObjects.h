// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Google Monitoring API (monitoring/v3)
// Description:
//   Manages your Stackdriver monitoring data and configurations. Projects must
//   be associated with a Stackdriver account, except for the following methods:
//   [monitoredResourceDescriptors.list](v3/projects.monitoredResourceDescriptors/list),
//   [monitoredResourceDescriptors.get](v3/projects.monitoredResourceDescriptors/get),
//   [metricDescriptors.list](v3/projects.metricDescriptors/list),
//   [metricDescriptors.get](v3/projects.metricDescriptors/get), and
//   [timeSeries.list](v3/projects.timeSeries/list).
// Documentation:
//   https://cloud.google.com/monitoring/api/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRMonitoring_BucketOptions;
@class GTLRMonitoring_CollectdPayload;
@class GTLRMonitoring_CollectdPayloadMetadata;
@class GTLRMonitoring_CollectdValue;
@class GTLRMonitoring_Distribution;
@class GTLRMonitoring_Explicit;
@class GTLRMonitoring_Exponential;
@class GTLRMonitoring_Field;
@class GTLRMonitoring_Group;
@class GTLRMonitoring_LabelDescriptor;
@class GTLRMonitoring_Linear;
@class GTLRMonitoring_Metric;
@class GTLRMonitoring_MetricDescriptor;
@class GTLRMonitoring_MetricLabels;
@class GTLRMonitoring_MonitoredResource;
@class GTLRMonitoring_MonitoredResourceDescriptor;
@class GTLRMonitoring_MonitoredResourceLabels;
@class GTLRMonitoring_Option;
@class GTLRMonitoring_OptionValue;
@class GTLRMonitoring_Point;
@class GTLRMonitoring_Range;
@class GTLRMonitoring_SourceContext;
@class GTLRMonitoring_TimeInterval;
@class GTLRMonitoring_TimeSeries;
@class GTLRMonitoring_TypedValue;

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRMonitoring_CollectdValue.dataSourceType

/** Value: "ABSOLUTE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Absolute;
/** Value: "COUNTER" */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Counter;
/** Value: "DERIVE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Derive;
/** Value: "GAUGE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Gauge;
/** Value: "UNSPECIFIED_DATA_SOURCE_TYPE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_UnspecifiedDataSourceType;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Field.cardinality

/** Value: "CARDINALITY_OPTIONAL" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityOptional;
/** Value: "CARDINALITY_REPEATED" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityRepeated;
/** Value: "CARDINALITY_REQUIRED" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityRequired;
/** Value: "CARDINALITY_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityUnknown;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Field.kind

/** Value: "TYPE_BOOL" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeBool;
/** Value: "TYPE_BYTES" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeBytes;
/** Value: "TYPE_DOUBLE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeDouble;
/** Value: "TYPE_ENUM" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeEnum;
/** Value: "TYPE_FIXED32" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFixed32;
/** Value: "TYPE_FIXED64" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFixed64;
/** Value: "TYPE_FLOAT" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFloat;
/** Value: "TYPE_GROUP" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeGroup;
/** Value: "TYPE_INT32" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeInt32;
/** Value: "TYPE_INT64" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeInt64;
/** Value: "TYPE_MESSAGE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeMessage;
/** Value: "TYPE_SFIXED32" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSfixed32;
/** Value: "TYPE_SFIXED64" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSfixed64;
/** Value: "TYPE_SINT32" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSint32;
/** Value: "TYPE_SINT64" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSint64;
/** Value: "TYPE_STRING" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeString;
/** Value: "TYPE_UINT32" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUint32;
/** Value: "TYPE_UINT64" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUint64;
/** Value: "TYPE_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUnknown;

// ----------------------------------------------------------------------------
// GTLRMonitoring_LabelDescriptor.valueType

/** Value: "BOOL" */
GTLR_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_Bool;
/** Value: "INT64" */
GTLR_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_Int64;
/** Value: "STRING" */
GTLR_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_String;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptor.metricKind

/** Value: "CUMULATIVE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Cumulative;
/** Value: "DELTA" */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Delta;
/** Value: "GAUGE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Gauge;
/** Value: "METRIC_KIND_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_MetricKindUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptor.valueType

/** Value: "BOOL" */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Bool;
/** Value: "DISTRIBUTION" */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Distribution;
/** Value: "DOUBLE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Double;
/** Value: "INT64" */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Int64;
/** Value: "MONEY" */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Money;
/** Value: "STRING" */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_String;
/** Value: "VALUE_TYPE_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_ValueTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_TimeSeries.metricKind

/** Value: "CUMULATIVE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Cumulative;
/** Value: "DELTA" */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Delta;
/** Value: "GAUGE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Gauge;
/** Value: "METRIC_KIND_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_MetricKindUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_TimeSeries.valueType

/** Value: "BOOL" */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Bool;
/** Value: "DISTRIBUTION" */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Distribution;
/** Value: "DOUBLE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Double;
/** Value: "INT64" */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Int64;
/** Value: "MONEY" */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Money;
/** Value: "STRING" */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_String;
/** Value: "VALUE_TYPE_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_ValueTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Type.syntax

/** Value: "SYNTAX_PROTO2" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Type_Syntax_SyntaxProto2;
/** Value: "SYNTAX_PROTO3" */
GTLR_EXTERN NSString * const kGTLRMonitoring_Type_Syntax_SyntaxProto3;

/**
 *  A Distribution may optionally contain a histogram of the values in the
 *  population. The histogram is given in `bucket_counts` as counts of values
 *  that fall into one of a sequence of non-overlapping buckets. The sequence of
 *  buckets is described by `bucket_options`. A bucket specifies an inclusive
 *  lower bound and exclusive upper bound for the values that are counted for
 *  that bucket. The upper bound of a bucket is strictly greater than the lower
 *  bound. The sequence of N buckets for a Distribution consists of an underflow
 *  bucket (number 0), zero or more finite buckets (number 1 through N - 2) and
 *  an overflow bucket (number N - 1). The buckets are contiguous: the lower
 *  bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1.
 *  The buckets span the whole range of finite values: lower bound of the
 *  underflow bucket is -infinity and the upper bound of the overflow bucket is
 *  +infinity. The finite buckets are so-called because both bounds are finite.
 *  `BucketOptions` describes bucket boundaries in one of three ways. Two
 *  describe the boundaries by giving parameters for a formula to generate
 *  boundaries and one gives the bucket boundaries explicitly. If
 *  `bucket_boundaries` is not given, then no `bucket_counts` may be given.
 */
@interface GTLRMonitoring_BucketOptions : GTLRObject

/** The explicit buckets. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Explicit *explicitBuckets;

/** The exponential buckets. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Exponential *exponentialBuckets;

/** The linear bucket. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Linear *linearBuckets;

@end


/**
 *  A collection of data points sent from a `collectd`-based plugin. See the
 *  `collectd` documentation for more information.
 */
@interface GTLRMonitoring_CollectdPayload : GTLRObject

/** The end time of the interval. */
@property(nonatomic, copy, nullable) NSString *endTime;

/** The measurement metadata. Example: `"process_id" -> 12345` */
@property(nonatomic, strong, nullable) GTLRMonitoring_CollectdPayloadMetadata *metadata;

/** The name of the plugin. Example: `"disk"`. */
@property(nonatomic, copy, nullable) NSString *plugin;

/** The instance name of the plugin Example: `"hdcl"`. */
@property(nonatomic, copy, nullable) NSString *pluginInstance;

/** The start time of the interval. */
@property(nonatomic, copy, nullable) NSString *startTime;

/** The measurement type. Example: `"memory"`. */
@property(nonatomic, copy, nullable) NSString *type;

/** The measurement type instance. Example: `"used"`. */
@property(nonatomic, copy, nullable) NSString *typeInstance;

/**
 *  The measured values during this time interval. Each value must have a
 *  different `dataSourceName`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdValue *> *values;

@end


/**
 *  The measurement metadata. Example: `"process_id" -> 12345`
 *
 *  @note This class is documented as having more properties of
 *        GTLRMonitoring_TypedValue. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_CollectdPayloadMetadata : GTLRObject
@end


/**
 *  A single data point from a `collectd`-based plugin.
 */
@interface GTLRMonitoring_CollectdValue : GTLRObject

/**
 *  The data source for the `collectd` value. For example there are two data
 *  sources for network measurements: `"rx"` and `"tx"`.
 */
@property(nonatomic, copy, nullable) NSString *dataSourceName;

/**
 *  The type of measurement.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Absolute Value
 *        "ABSOLUTE"
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Counter Value
 *        "COUNTER"
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Derive Value "DERIVE"
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Gauge Value "GAUGE"
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_UnspecifiedDataSourceType
 *        Value "UNSPECIFIED_DATA_SOURCE_TYPE"
 */
@property(nonatomic, copy, nullable) NSString *dataSourceType;

/** The measurement value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TypedValue *value;

@end


/**
 *  The `CreateCollectdTimeSeries` request.
 */
@interface GTLRMonitoring_CreateCollectdTimeSeriesRequest : GTLRObject

/**
 *  The `collectd` payloads representing the time series data. You must not
 *  include more than a single point for each time series, so no two payloads
 *  can have the same values for all of the fields `plugin`, `plugin_instance`,
 *  `type`, and `type_instance`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdPayload *> *collectdPayloads;

/**
 *  The version of `collectd` that collected the data. Example:
 *  `"5.3.0-192.el6"`.
 */
@property(nonatomic, copy, nullable) NSString *collectdVersion;

/** The monitored resource associated with the time series. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *resource;

@end


/**
 *  The `CreateTimeSeries` request.
 */
@interface GTLRMonitoring_CreateTimeSeriesRequest : GTLRObject

/**
 *  The new data to be added to a list of time series. Adds at most one data
 *  point to each of several time series. The new data point must be more recent
 *  than any other point in its time series. Each `TimeSeries` value must fully
 *  specify a unique time series by supplying all label values for the metric
 *  and the monitored resource.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_TimeSeries *> *timeSeries;

@end


/**
 *  Distribution contains summary statistics for a population of values and,
 *  optionally, a histogram representing the distribution of those values across
 *  a specified set of histogram buckets. The summary statistics are the count,
 *  mean, sum of the squared deviation from the mean, the minimum, and the
 *  maximum of the set of population of values. The histogram is based on a
 *  sequence of buckets and gives a count of values that fall into each bucket.
 *  The boundaries of the buckets are given either explicitly or by specifying
 *  parameters for a method of computing them (buckets of fixed width or buckets
 *  of exponentially increasing width). Although it is not forbidden, it is
 *  generally a bad idea to include non-finite values (infinities or NaNs) in
 *  the population of values, as this will render the `mean` and
 *  `sum_of_squared_deviation` fields meaningless.
 */
@interface GTLRMonitoring_Distribution : GTLRObject

/**
 *  If `bucket_options` is given, then the sum of the values in `bucket_counts`
 *  must equal the value in `count`. If `bucket_options` is not given, no
 *  `bucket_counts` fields may be given. Bucket counts are given in order under
 *  the numbering scheme described above (the underflow bucket has number 0; the
 *  finite buckets, if any, have numbers 1 through N-2; the overflow bucket has
 *  number N-1). The size of `bucket_counts` must be no greater than N as
 *  defined in `bucket_options`. Any suffix of trailing zero bucket_count fields
 *  may be omitted.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bucketCounts;

/** Defines the histogram bucket boundaries. */
@property(nonatomic, strong, nullable) GTLRMonitoring_BucketOptions *bucketOptions;

/**
 *  The number of values in the population. Must be non-negative.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  The arithmetic mean of the values in the population. If `count` is zero then
 *  this field must be zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mean;

/**
 *  If specified, contains the range of the population values. The field must
 *  not be present if the `count` is zero.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Range *range;

/**
 *  The sum of squared deviations from the mean of the values in the population.
 *  For values x_i this is: Sum[i=1..n]((x_i - mean)^2) Knuth, "The Art of
 *  Computer Programming", Vol. 2, page 323, 3rd edition describes Welford's
 *  method for accumulating this sum in one pass. If `count` is zero then this
 *  field must be zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sumOfSquaredDeviation;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON
 *  representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLRMonitoring_Empty : GTLRObject
@end


/**
 *  A set of buckets with arbitrary widths. Defines `size(bounds) + 1` (= N)
 *  buckets with these boundaries for bucket i: Upper bound (0 <= i < N-1):
 *  bounds[i] Lower bound (1 <= i < N); bounds[i - 1] There must be at least one
 *  element in `bounds`. If `bounds` has only one element, there are no finite
 *  buckets, and that single element is the common boundary of the overflow and
 *  underflow buckets.
 */
@interface GTLRMonitoring_Explicit : GTLRObject

/**
 *  The values must be monotonically increasing.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bounds;

@end


/**
 *  Specify a sequence of buckets that have a width that is proportional to the
 *  value of the lower bound. Each bucket represents a constant relative
 *  uncertainty on a specific value in the bucket. Defines `num_finite_buckets +
 *  2` (= N) buckets with these boundaries for bucket i: Upper bound (0 <= i <
 *  N-1): scale * (growth_factor ^ i). Lower bound (1 <= i < N): scale *
 *  (growth_factor ^ (i - 1)).
 */
@interface GTLRMonitoring_Exponential : GTLRObject

/**
 *  Must be greater than 1
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *growthFactor;

/**
 *  must be greater than 0
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  Must be greater than 0
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *scale;

@end


/**
 *  A single field of a message type.
 */
@interface GTLRMonitoring_Field : GTLRObject

/**
 *  The field cardinality.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityOptional Value
 *        "CARDINALITY_OPTIONAL"
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityRepeated Value
 *        "CARDINALITY_REPEATED"
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityRequired Value
 *        "CARDINALITY_REQUIRED"
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityUnknown Value
 *        "CARDINALITY_UNKNOWN"
 */
@property(nonatomic, copy, nullable) NSString *cardinality;

/**
 *  The string value of the default value of this field. Proto2 syntax only.
 */
@property(nonatomic, copy, nullable) NSString *defaultValue;

/** The field JSON name. */
@property(nonatomic, copy, nullable) NSString *jsonName;

/**
 *  The field type.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeBool Value "TYPE_BOOL"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeBytes Value "TYPE_BYTES"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeDouble Value "TYPE_DOUBLE"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeEnum Value "TYPE_ENUM"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFixed32 Value "TYPE_FIXED32"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFixed64 Value "TYPE_FIXED64"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFloat Value "TYPE_FLOAT"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeGroup Value "TYPE_GROUP"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeInt32 Value "TYPE_INT32"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeInt64 Value "TYPE_INT64"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeMessage Value "TYPE_MESSAGE"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSfixed32 Value "TYPE_SFIXED32"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSfixed64 Value "TYPE_SFIXED64"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSint32 Value "TYPE_SINT32"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSint64 Value "TYPE_SINT64"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeString Value "TYPE_STRING"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUint32 Value "TYPE_UINT32"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUint64 Value "TYPE_UINT64"
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUnknown Value "TYPE_UNKNOWN"
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** The field name. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The field number.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *number;

/**
 *  The index of the field type in `Type.oneofs`, for message or enumeration
 *  types. The first type has index 1; zero means the type is not in the list.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *oneofIndex;

/** The protocol buffer options. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Option *> *options;

/**
 *  Whether to use alternative packed wire representation.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *packed;

/**
 *  The field type URL, without the scheme, for message or enumeration types.
 *  Example: `"type.googleapis.com/google.protobuf.Timestamp"`.
 */
@property(nonatomic, copy, nullable) NSString *typeUrl;

@end


/**
 *  The description of a dynamic collection of monitored resources. Each group
 *  has a filter that is matched against monitored resources and their
 *  associated metadata. If a group's filter matches an available monitored
 *  resource, then that resource is a member of that group. Groups can contain
 *  any number of monitored resources, and each monitored resource can be a
 *  member of any number of groups. Groups can be nested in parent-child
 *  hierarchies. The `parentName` field identifies an optional parent for each
 *  group. If a group has a parent, then the only monitored resources available
 *  to be matched by the group's filter are the resources contained in the
 *  parent group. In other words, a group contains the monitored resources that
 *  match its filter and the filters of all the group's ancestors. A group
 *  without a parent can contain any monitored resource. For example, consider
 *  an infrastructure running a set of instances with two user-defined tags:
 *  `"environment"` and `"role"`. A parent group has a filter,
 *  `environment="production"`. A child of that parent group has a filter,
 *  `role="transcoder"`. The parent group contains all instances in the
 *  production environment, regardless of their roles. The child group contains
 *  instances that have the transcoder role *and* are in the production
 *  environment. The monitored resources contained in a group can change at any
 *  moment, depending on what resources exist and what filters are associated
 *  with the group and its ancestors.
 */
@interface GTLRMonitoring_Group : GTLRObject

/** A user-assigned name for this group, used only for display purposes. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The filter used to determine which monitored resources belong to this group.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  If true, the members of this group are considered to be a cluster. The
 *  system can perform additional analysis on groups that are clusters.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isCluster;

/**
 *  The name of this group. The format is
 *  `"projects/{project_id_or_number}/groups/{group_id}"`. When creating a
 *  group, this field is ignored and a new name is created consisting of the
 *  project specified in the call to `CreateGroup` and a unique `{group_id}`
 *  that is generated automatically. \@OutputOnly
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The name of the group's parent, if it has one. The format is
 *  `"projects/{project_id_or_number}/groups/{group_id}"`. For groups with no
 *  parent, `parentName` is the empty string, `""`.
 */
@property(nonatomic, copy, nullable) NSString *parentName;

@end


/**
 *  A description of a label.
 */
@interface GTLRMonitoring_LabelDescriptor : GTLRObject

/**
 *  A human-readable description for the label.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The label key. */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  The type of data that can be assigned to the label.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_Bool Value "BOOL"
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_Int64 Value "INT64"
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_String Value "STRING"
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  Specify a sequence of buckets that all have the same width (except overflow
 *  and underflow). Each bucket represents a constant absolute uncertainty on
 *  the specific value in the bucket. Defines `num_finite_buckets + 2` (= N)
 *  buckets with these boundaries for bucket `i`: Upper bound (0 <= i < N-1):
 *  offset + (width * i). Lower bound (1 <= i < N): offset + (width * (i - 1)).
 */
@interface GTLRMonitoring_Linear : GTLRObject

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  Lower bound of the first bucket.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *offset;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *width;

@end


/**
 *  The `ListGroupMembers` response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "members" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListGroupMembersResponse : GTLRCollectionObject

/**
 *  A set of monitored resources in the group.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MonitoredResource *> *members;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  `pageToken` in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The total number of elements matching this request.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalSize;

@end


/**
 *  The `ListGroups` response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "group" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListGroupsResponse : GTLRCollectionObject

/**
 *  The groups that match the specified filters.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Group *> *group;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  `pageToken` in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The `ListMetricDescriptors` response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "metricDescriptors" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListMetricDescriptorsResponse : GTLRCollectionObject

/**
 *  The metric descriptors that are available to the project and that match the
 *  value of `filter`, if present.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MetricDescriptor *> *metricDescriptors;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  `pageToken` in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The `ListMonitoredResourcDescriptors` response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "resourceDescriptors" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListMonitoredResourceDescriptorsResponse : GTLRCollectionObject

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  `pageToken` in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The monitored resource descriptors that are available to this project and
 *  that match `filter`, if present.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MonitoredResourceDescriptor *> *resourceDescriptors;

@end


/**
 *  The `ListTimeSeries` response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "timeSeries" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListTimeSeriesResponse : GTLRCollectionObject

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  `pageToken` in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  One or more time series that match the filter included in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_TimeSeries *> *timeSeries;

@end


/**
 *  A specific metric identified by specifying values for all of the labels of a
 *  `MetricDescriptor`.
 */
@interface GTLRMonitoring_Metric : GTLRObject

/**
 *  The set of labels that uniquely identify a metric. To specify a metric, all
 *  labels enumerated in the `MetricDescriptor` must be assigned values.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MetricLabels *labels;

/**
 *  An existing metric type, see google.api.MetricDescriptor. For example,
 *  `compute.googleapis.com/instance/cpu/usage_time`.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  The set of labels that uniquely identify a metric. To specify a metric, all
 *  labels enumerated in the `MetricDescriptor` must be assigned values.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_MetricLabels : GTLRObject
@end


/**
 *  Defines a metric type and its schema.
 */
@interface GTLRMonitoring_MetricDescriptor : GTLRObject

/**
 *  A detailed description of the metric, which can be used in documentation.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A concise name for the metric, which can be displayed in user interfaces.
 *  Use sentence case without an ending period, for example "Request count".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The set of labels that can be used to describe a specific instance of this
 *  metric type. For example, the
 *  `compute.googleapis.com/instance/network/received_bytes_count` metric type
 *  has a label, `loadbalanced`, that specifies whether the traffic was received
 *  through a load balanced IP address.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labels;

/**
 *  Whether the metric records instantaneous values, changes to a value, etc.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Cumulative Value
 *        "CUMULATIVE"
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Delta Value "DELTA"
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Gauge Value "GAUGE"
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_MetricKindUnspecified
 *        Value "METRIC_KIND_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *metricKind;

/**
 *  Resource name. The format of the name may vary between different
 *  implementations. For examples:
 *  projects/{project_id}/metricDescriptors/{type=**}
 *  metricDescriptors/{type=**}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The metric type including a DNS name prefix, for example
 *  `"compute.googleapis.com/instance/cpu/utilization"`. Metric types should use
 *  a natural hierarchical grouping such as the following:
 *  compute.googleapis.com/instance/cpu/utilization
 *  compute.googleapis.com/instance/disk/read_ops_count
 *  compute.googleapis.com/instance/network/received_bytes_count Note that if
 *  the metric type changes, the monitoring data will be discontinued, and
 *  anything depends on it will break, such as monitoring dashboards, alerting
 *  rules and quota limits. Therefore, once a metric has been published, its
 *  type should be immutable.
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  The unit in which the metric value is reported. It is only applicable if the
 *  `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The supported units
 *  are a subset of [The Unified Code for Units of
 *  Measure](http://unitsofmeasure.org/ucum.html) standard: **Basic units
 *  (UNIT)** * `bit` bit * `By` byte * `s` second * `min` minute * `h` hour *
 *  `d` day **Prefixes (PREFIX)** * `k` kilo (10**3) * `M` mega (10**6) * `G`
 *  giga (10**9) * `T` tera (10**12) * `P` peta (10**15) * `E` exa (10**18) *
 *  `Z` zetta (10**21) * `Y` yotta (10**24) * `m` milli (10**-3) * `u` micro
 *  (10**-6) * `n` nano (10**-9) * `p` pico (10**-12) * `f` femto (10**-15) *
 *  `a` atto (10**-18) * `z` zepto (10**-21) * `y` yocto (10**-24) * `Ki` kibi
 *  (2**10) * `Mi` mebi (2**20) * `Gi` gibi (2**30) * `Ti` tebi (2**40)
 *  **Grammar** The grammar includes the dimensionless unit `1`, such as `1/s`.
 *  The grammar also includes these connectors: * `/` division (as an infix
 *  operator, e.g. `1/s`). * `.` multiplication (as an infix operator, e.g.
 *  `GBy.d`) The grammar for a unit is as follows: Expression = Component { "."
 *  Component } { "/" Component } ; Component = [ PREFIX ] UNIT [ Annotation ] |
 *  Annotation | "1" ; Annotation = "{" NAME "}" ; Notes: * `Annotation` is just
 *  a comment if it follows a `UNIT` and is equivalent to `1` if it is used
 *  alone. For examples, `{requests}/s == 1/s`, `By{transmitted}/s == By/s`. *
 *  `NAME` is a sequence of non-blank printable ASCII characters not containing
 *  '{' or '}'.
 */
@property(nonatomic, copy, nullable) NSString *unit;

/**
 *  Whether the measurement is an integer, a floating-point number, etc.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Bool Value "BOOL"
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Distribution Value
 *        "DISTRIBUTION"
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Double Value "DOUBLE"
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Int64 Value "INT64"
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Money Value "MONEY"
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_String Value "STRING"
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_ValueTypeUnspecified
 *        Value "VALUE_TYPE_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  An object representing a resource that can be used for monitoring, logging,
 *  billing, or other purposes. Examples include virtual machine instances,
 *  databases, and storage devices such as disks. The `type` field identifies a
 *  MonitoredResourceDescriptor object that describes the resource's schema.
 *  Information in the `labels` field identifies the actual resource and its
 *  attributes according to the schema. For example, a particular Compute Engine
 *  VM instance could be represented by the following object, because the
 *  MonitoredResourceDescriptor for `"gce_instance"` has labels `"instance_id"`
 *  and `"zone"`: { "type": "gce_instance", "labels": { "instance_id":
 *  "my-instance", "zone": "us-central1-a" }}
 */
@interface GTLRMonitoring_MonitoredResource : GTLRObject

/**
 *  Required. Values for all of the labels listed in the associated monitored
 *  resource descriptor. For example, Cloud SQL databases use the labels
 *  `"database_id"` and `"zone"`.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResourceLabels *labels;

/**
 *  Required. The monitored resource type. This field must match the `type`
 *  field of a MonitoredResourceDescriptor object. For example, the type of a
 *  Cloud SQL database is `"cloudsql_database"`.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Required. Values for all of the labels listed in the associated monitored
 *  resource descriptor. For example, Cloud SQL databases use the labels
 *  `"database_id"` and `"zone"`.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_MonitoredResourceLabels : GTLRObject
@end


/**
 *  An object that describes the schema of a MonitoredResource object using a
 *  type name and a set of labels. For example, the monitored resource
 *  descriptor for Google Compute Engine VM instances has a type of
 *  `"gce_instance"` and specifies the use of the labels `"instance_id"` and
 *  `"zone"` to identify particular VM instances. Different APIs can support
 *  different monitored resource types. APIs generally provide a `list` method
 *  that returns the monitored resource descriptors used by the API.
 */
@interface GTLRMonitoring_MonitoredResourceDescriptor : GTLRObject

/**
 *  Optional. A detailed description of the monitored resource type that might
 *  be used in documentation.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. A concise name for the monitored resource type that might be
 *  displayed in user interfaces. For example, `"Google Cloud SQL Database"`.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Required. A set of labels used to describe instances of this monitored
 *  resource type. For example, an individual Google Cloud SQL database is
 *  identified by values for the labels `"database_id"` and `"zone"`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labels;

/**
 *  Optional. The resource name of the monitored resource descriptor:
 *  `"projects/{project_id}/monitoredResourceDescriptors/{type}"` where {type}
 *  is the value of the `type` field in this object and {project_id} is a
 *  project ID that provides API-specific context for accessing the type. APIs
 *  that do not use project information can use the resource name format
 *  `"monitoredResourceDescriptors/{type}"`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. The monitored resource type. For example, the type
 *  `"cloudsql_database"` represents databases in Google Cloud SQL.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A protocol buffer option, which can be attached to a message, field,
 *  enumeration, etc.
 */
@interface GTLRMonitoring_Option : GTLRObject

/** The option's name. For example, `"java_package"`. */
@property(nonatomic, copy, nullable) NSString *name;

/** The option's value. For example, `"com.google.protobuf"`. */
@property(nonatomic, strong, nullable) GTLRMonitoring_OptionValue *value;

@end


/**
 *  The option's value. For example, `"com.google.protobuf"`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_OptionValue : GTLRObject
@end


/**
 *  A single data point in a time series.
 */
@interface GTLRMonitoring_Point : GTLRObject

/** The time interval to which the value applies. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TimeInterval *interval;

/** The value of the data point. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TypedValue *value;

@end


/**
 *  The range of the population values.
 */
@interface GTLRMonitoring_Range : GTLRObject

/**
 *  The maximum of the population values.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *max;

/**
 *  The minimum of the population values.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *min;

@end


/**
 *  `SourceContext` represents information about the source of a protobuf
 *  element, like the file in which it is defined.
 */
@interface GTLRMonitoring_SourceContext : GTLRObject

/**
 *  The path-qualified name of the .proto file that contained the associated
 *  protobuf element. For example: `"google/protobuf/source.proto"`.
 */
@property(nonatomic, copy, nullable) NSString *fileName;

@end


/**
 *  A time interval extending from after `startTime` through `endTime`. If
 *  `startTime` is omitted, the interval is the single point in time, `endTime`.
 */
@interface GTLRMonitoring_TimeInterval : GTLRObject

/** Required. The end of the interval. The interval includes this time. */
@property(nonatomic, copy, nullable) NSString *endTime;

/**
 *  If this value is omitted, the interval is a point in time, `endTime`. If
 *  `startTime` is present, it must be earlier than (less than) `endTime`. The
 *  interval begins after `startTime`—it does not include `startTime`.
 */
@property(nonatomic, copy, nullable) NSString *startTime;

@end


/**
 *  A collection of data points that describes the time-varying nature of a
 *  metric. A time series is identified by a combination of a fully-specified
 *  monitored resource and a fully-specified metric.
 */
@interface GTLRMonitoring_TimeSeries : GTLRObject

/** The fully-specified metric used to identify the time series. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Metric *metric;

/**
 *  The metric kind of the time series. This can be different than the metric
 *  kind specified in [google.api.MetricDescriptor] because of alignment and
 *  reduction operations on the data. This field is ignored when writing data;
 *  the value specified in the descriptor is used instead. \@OutputOnly
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Cumulative Value
 *        "CUMULATIVE"
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Delta Value "DELTA"
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Gauge Value "GAUGE"
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_MetricKindUnspecified Value
 *        "METRIC_KIND_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *metricKind;

/**
 *  The data points of this time series. When used as output, points will be
 *  sorted by decreasing time order. When used as input, points could be written
 *  in any orders.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Point *> *points;

/**
 *  The fully-specified monitored resource used to identify the time series.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *resource;

/**
 *  The value type of the time series. This can be different than the value type
 *  specified in [google.api.MetricDescriptor] because of alignment and
 *  reduction operations on the data. This field is ignored when writing data;
 *  the value specified in the descriptor is used instead. \@OutputOnly
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Bool Value "BOOL"
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Distribution Value
 *        "DISTRIBUTION"
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Double Value "DOUBLE"
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Int64 Value "INT64"
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Money Value "MONEY"
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_String Value "STRING"
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_ValueTypeUnspecified Value
 *        "VALUE_TYPE_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  A protocol buffer message type.
 */
@interface GTLRMonitoring_Type : GTLRObject

/** The list of fields. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Field *> *fields;

/** The fully qualified message name. */
@property(nonatomic, copy, nullable) NSString *name;

/** The list of types appearing in `oneof` definitions in this type. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *oneofs;

/** The protocol buffer options. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Option *> *options;

/** The source context. */
@property(nonatomic, strong, nullable) GTLRMonitoring_SourceContext *sourceContext;

/**
 *  The source syntax.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Type_Syntax_SyntaxProto2 Value "SYNTAX_PROTO2"
 *    @arg @c kGTLRMonitoring_Type_Syntax_SyntaxProto3 Value "SYNTAX_PROTO3"
 */
@property(nonatomic, copy, nullable) NSString *syntax;

@end


/**
 *  A single strongly-typed value.
 */
@interface GTLRMonitoring_TypedValue : GTLRObject

/**
 *  A Boolean value: `true` or `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *boolValue;

/** A distribution value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Distribution *distributionValue;

/**
 *  A 64-bit double-precision floating-point number. Its magnitude is
 *  approximately ±10±300 and it has 16 significant digits of precision.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *doubleValue;

/**
 *  A 64-bit integer. Its range is approximately ±9.2x1018.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *int64Value;

/** A variable-length string value. */
@property(nonatomic, copy, nullable) NSString *stringValue;

@end

NS_ASSUME_NONNULL_END
